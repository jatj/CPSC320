% Created 2019-01-07 Mon 15:15
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algpseudocode}
\usepackage[margin=0.75in]{geometry}
\usepackage{nth}
\usepackage{tikz}
\usetikzlibrary{positioning,chains,fit,shapes,shapes.misc,calc,arrows,patterns,decorations.pathreplacing}
\usepackage{ccicons}
\usepackage{calc}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{nopageno}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{braket}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\setlength{\columnseprule}{1pt}
\newcommand{\Match}{\mbox{Match}}
\newcommand{\Score}{\mbox{Score}}
\newcommand{\bonusmarksamt}[1]{\textbf{[#1~BONUS~marks]}}
\newcommand{\bonusmarkamt}[0]{\textbf{[1~BONUS~mark]}}
\newcommand{\marksamt}[1]{\textbf{[#1~marks]}}
\newcommand{\markamt}[0]{\textbf{[1~mark]}}
\newcommand{\fillinMC}[1]{\fillinMCmath{\mbox{#1}}}
\newcommand{\fillinMCmath}[1]{\begin{tikzpicture}\draw circle [radius=0.5em];\end{tikzpicture}\ #1}
\newcommand{\fillinMCsoln}[1]{\fillinMCmathsoln{\mbox{#1}}}
\newcommand{\fillinMCmathsoln}[1]{\begin{tikzpicture}\draw[black, fill=blue] circle [radius=0.5em];\end{tikzpicture}\ #1}
\newcommand{\fillinMCAll}[1]{\fillinMCAllmath{\mbox{#1}}}
\newcommand{\fillinMCAllmath}[1]{\begin{tikzpicture}\draw (0,0) rectangle (1em,1em);\end{tikzpicture}\ #1}
\newcommand{\fillinMCAllsoln}[1]{\fillinMCAllmathsoln{\mbox{#1}}}
\newcommand{\fillinMCAllmathsoln}[1]{\begin{tikzpicture}\draw[black, fill=blue] (0,0) rectangle (1em,1em);\end{tikzpicture}\ #1}
\newcommand{\fillinblank}[1]{\fillinblankmath{\mbox{#1}}}
\newcommand{\fillinblankmath}[1]{\begingroup\setlength{\fboxsep}{1em}\setlength{\fboxrule}{2pt}\fbox{\LARGE\phantom{#1}}\endgroup}
\newcommand{\fillinblanksoln}[1]{\fillinblankmathsoln{\mbox{#1}}}
\newcommand{\fillinblankmathsoln}[1]{\begingroup\setlength{\fboxsep}{1em}\setlength{\fboxrule}{2pt}\fbox{{#1}}\endgroup}
\newcommand{\answerbox}[1][3\baselineskip]{%
\noindent\setlength{\fboxrule}{2pt}\framebox[0.7\linewidth]{%
\raisebox{2pt}[0pt][#1]{}%
}\par\medskip%
}
\usepackage{collcell,array}
\newcommand{\shiftdown}[1]{\smash{\raisebox{-.5\normalbaselineskip}{#1}}}
\newcolumntype{C}{>{\collectcell\shiftdown}c<{\endcollectcell}}
\newcommand{\shiftup}[1]{\smash{\raisebox{.5\normalbaselineskip}{#1}}}
%\fancyhead{}\fancyfoot[C]{\tiny This work is licensed under a \href{http://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License. \ccby}\\ For license purposes, the author is the University of British Columbia.}\pagestyle{fancyplain}
\fancyhead{}\fancyfoot[C]{\tiny This work is licensed under a \href{http://creativecommons.org/licenses/by-nc/4.0/}{Creative Commons Attribution-NonCommercial 4.0 International License. \ccbync}\\ For license purposes, the author is the University of British Columbia.}\pagestyle{fancyplain}
\date{}
\title{CPSC 320 2018W2: Assignment 1}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.2.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
Please submit this assignment via \href{https://gradescope.com/}{GradeScope} at
\url{https://gradescope.com}, 
by \textbf{Monday January 21 at 10pm}. Assignments,
submitted within 24 hours after the deadline will be accepted, but a penalty
of 15\% will be applied.

Be sure to identify everyone in your group if
you're making a group submission. Reminder: groups can include a
maximum of three students; we strongly encourage groups of two.
Your group must make a \textbf{single} submission via one group member's account,
marking all other group members in that submission \textbf{using GradeScope's
interface}. Your group's submission \textbf{must}:
\begin{itemize}
\item Consist of a single, clearly legible file uploadable to GradeScope
with clearly indicated solutions to the problems. (PDFs produced via
\LaTeX{}, Word, Google Docs, or other editing software work
well. Scanned documents will likely work well. \textbf{High-quality}
photographs are OK if we agree they're legible.)
\item Include prominent numbering that corresponds to the numbering used
in this assignment handout. Put
these \textbf{in order} starting each problem on a new page, ideally. If
not, \textbf{very clearly} and prominently indicate which problem is
answered where.
\item Include at the start of the document the \textbf{ugrad.cs.ubc.ca e-mail
addresses} of each member of your team. (Please do \textbf{NOT} include
your name on the assignment, however. If you don't mind private
information being stored outside Canada and want an extra
double-check on your identity, include your student number rather
than your name.)
\item Include at the start of the document the statement: "All group
members have read and followed the guidelines for groupwork
on assignments in CPSC320. 
As part of those rules, when collaborating with anyone
outside my group, (1) I and my collaborators took no record but
names (and GradeScope information) away, and (2) after a suitable
break, my group created the assignment I am submitting without help
from anyone other than the course staff." (Go read those
guidelines! They are posted on the
course website, along with the links to the assignments.)

\item Include at the start of the document your outside-group
collaborators' ugrad.cs.ubc.ca IDs, but \textbf{not} their names. (Be sure
to get those IDs when you collaborate!)
\end{itemize}

Before  we  begin, a  few  notes  on  pseudocode  throughout CPSC  320:  Your
pseudocode must  communicate your
algorithm  clearly,  concisely,  correctly, and  without  irrelevant  detail.
Reasonable  use of  plain  English is  fine in  such  pseudocode. You  should
envision your  audience as  a capable  CPSC 320  student unfamiliar  with the
problem you are solving. If you choose  to use actual code, note that you may
\textbf{neither} include what we consider to  be irrelevant detail \textbf{nor} assume that
we understand  the particular language  you chose.  (So, for example,  do not
write  \texttt{\#include <iostream>}  at  the  start of  your  pseudocode, and  avoid
idiosyncratic    features   of    your   language    like   Java's    ternary
(question-mark-colon) operator.)

Remember also to \textbf{justify your answers}. Justifications/explanations need not
be long or formal, but should be clear and specific.

\clearpage
\section{SMP and Gale-Shapley}
\label{sec-1}

\begin{enumerate}
\item Let $\#E_k$ be the number of employers matched at the end of the
$k\mbox{th}$ iteration of the While loop on some execution of the
G-S algorithm. If there are at least $k+1$ iterations of the
While loop, must it be the case that $\#E_k < \#E_{k+1}$?

\item Let Set-$A_k$ be the set of applicants matched at
the end of the $k\mbox{th}$ iteration of the While loop on some
execution of the G-S
algorithm. If there are at least $k+1$ iterations of the
While loop, must it be the case that 
Set-$A_k \subseteq$ Set-$A_{k+1}$?

\item Consider a variant of SMP in which each of $n$ employers has exactly
\textbf{two} positions, and the number of applicants is $2n$.  As a function
of $n$, how many valid solutions are there?
\end{enumerate}

\section{Progressing Towards Goodness in Gale-Shapley}
\label{sec-2}
Prove the following claim, from part 8.1 of the Stable Matching
Problem Part II worksheet. You could use a proof by induction, with a
structure that is modeled on the proof of problem 5.2 of the
worksheet.

\vspace{.1in}

\noindent \textbf{Claim:} At the end of every iteration $k$ of the
While loop of Algorithm G-S, every employer $e$ has only considered
applicants that it ranks at least as high as best($e$).  Moreover, if
$e$ has considered best($e$) on or before iteration $k$, then $e$ is
matched with best($e$) at the end of iteration $k$.

\section{SMP with Identical Preference Lists}
\label{sec-3}
For positive integers $n$, let $I_n$ be the instance of SMP with $n$
employers and $n$ applicants such that every employer has the same
preference list, and also every applicant has the same preference list, namely:
\[
e_i: a_1, a_2, \ldots, a_n  \mbox{\hspace{1in}}
a_i: e_1, e_2, \ldots, e_n.
\]
Let $S$ be the (infinite) set of instances $\{I_n, n>0\}$.

\begin{enumerate}
\item Write down the instance $I_2$. (No justification needed.)

\item Show a good solution for the instance $I_2$. (No justification needed.)

\item Prove that for any $n>0$, in the instance $I_n$ we have best($e_i$) $= a_i$,
for $1 \le i \le n$.
\end{enumerate}

\section{Faster or Slower}
\label{sec-4}
Suppose that some algorithm $A$ has running time $f(n)$ and that
algorithm $B$ has running time $g(n)$, on all inputs of size $n$.
Assume that $f$ and $g$ are functions $\mathbb{N} \rightarrow \mathbb{N}^+$, and that
$\lim_{n \rightarrow \infty} f(n)$ and $\lim_{n \rightarrow \infty} g(n)$ are both infinity.
Explain whether each statement in parts 2 and 3 below is true or false.
Part 1 is already done for you.

\begin{enumerate}
\item For some choice of $g(n)$ with $g(n) \in \Omega(f(n) \log n)$:
\begin{enumerate}
\item $A$ is faster than $B$ on all sufficiently large inputs.

\textbf{SOLUTION}
True. Choosing $g(n) = f(n) (\lceil \log_2 n \rceil + 1)$ satisfies the condition that
$g(n) \in \Omega(f(n) \log n)$.  For this choice, $g(n) > f(n)$
for all $n$, and so $B$ is slower than $A$ on all inputs.

\item $A$ is slower than $B$ on all sufficiently large inputs.

\textbf{SOLUTION}
False. For all choices of $g$ with $g(n) \in
     \Omega(f(n) \log n)$, we have that $g(n) > f(n)$ for sufficiently large $n$. 
So $B$ is slower than $A$ on all sufficiently large inputs.

\item $A$ is faster than $B$ on some inputs, and slower than $B$ on other inputs.

\textbf{SOLUTION} True. Let $n_1 < n_2$ be such that $f(n_1) > 1$ and $f(n_2) > 1$.
Choose $g(n) = 1$ for $n \le n_2$ and $g(n) = f(n) \lceil \log_2 n \rceil$ for $n > n_2$.
Then $g(n) \in \Omega(f(n) \log n)$, $g(n) > f(n)$
for all $n > n_2$, and $g(n) < f(n)$ for $n_1$ and $n_2$.
So $B$ is faster than $A$ on inputs $n_1$ and $n_2$, while being slower
than $A$ on all inputs of size greater than $n_2$.
\end{enumerate}

\item For some choice of $g$ such that $g(n) \in \Theta(f(n))$:
\begin{enumerate}
\item $A$ is faster than $B$ on all sufficiently large inputs.

\item $A$ is slower than $B$ on all sufficiently large inputs.

\item $A$ is faster than $B$ on some inputs, and slower than $B$ on other inputs.
\end{enumerate}

\item For some choice of $g$ such that $g(n) \in o(f(n))$:

\begin{enumerate}
\item $A$ is faster than $B$ on all sufficiently large inputs.

\item $A$ is slower than $B$ on all sufficiently large inputs.

\item $A$ is faster than $B$ on some inputs, and slower than $B$ on other inputs.
\end{enumerate}
\end{enumerate}

\section{Comparing Substrings}
\label{sec-5}
Here you'll evaluate running times of algorithms whose
input size is expressed using two parameters.

Let $T[1..n]$ and $T'[1..n]$ be strings of length $n$, over a finite alphabet
(For example, $T$ and $T'$ might be over the alphabet $\{A,C,G,T\}$,
and represent DNA strands.)
A function Match indicates whether or not a letter of $T$ matches a
letter of $T'$.  That is, for $1 \le i,j \le n$, 

\[
\begin{array}{lll}
\Match(i,j) & = 1, & \mbox{ if } T[i] = T'[j] \\
         & = 0, & \mbox{ otherwise}.
\end{array}
\]
Fix $k, 1 \le k \le n$.
For $1 \le i,j \le n-k+1$, the \emph{score} of any two
length-$k$ substrings $T[i..i+k-1]$ and $T'[j..j+k-1]$ of $T$ and $T'$
respectively is given by
\[
\sum_{l = 0}^{k-1} \Match(i+l,j+l).
\]
Algorithm \emph{Compute-Scores} below computes all scores and stores them
in a two-dimensional array called Score.  Assume that calls to
function Match take $\Theta(1)$ time and that array Score has
already been created.

\begin{tabbing}
xxx\=xxx\=xxx\=xxxxxxx\= \kill
{\bf Algorithm} {\em Compute-Scores} ($T[1..n],T'[1..n],k$)$ \\
     \> // $T$ and $T'$ are length-$n$ strings and $1\le k \le n$ \\
     \> For $i$ from 1 to $n-k+1$ \\
     \>\> For $j$ from 1 to $n-k+1$ \\
     \>\>\> // compute score of $T[i..i+k-1]$ and $T'[j..j+k-1]$ and store in $\Score[i,j]$ \\
     \>\>\>  $\Score[i,j] = \sum_{l = 0}^{k-1} \Match(i+l,j+l)$ \\
\end{tabbing}

\begin{enumerate}
\item What terms below describe the worst-case running time of this
algorithm?  Check all answers that apply.  Here, a term
$\Theta(f(n,k))$ is correct if for any choice of $k$ in the range
$[1..n]$, the algorithm runs in $O(f(n,k))$ time, and for some
choice of $k$ in the range $[1..n]$ (where $k$ may be expressed as
a function of $n$), the algorithm runs in $\Omega(f(n,k))$ time.

$\fillinMC{}$ $\Theta(k^3)$ \hspace{.6in} 
$\fillinMC{}$ $\Theta((n-k)^2 k)$   \hspace{.6in} 
$\fillinMC{}$ $\Theta(n^2 k)$   \hspace{.6in} 
$\fillinMC{}$ $\Theta(n^3)$

\item Modify the algorithm of part 1, to improve the runtime by a factor of $k$.

\item What is the worst-case running time of your algorithm of part 2?
Try to find as simple an expression as possible.
\end{enumerate}
% Emacs 25.2.1 (Org mode 8.2.10)
\end{document}
