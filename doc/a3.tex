% Created 2019-02-06 Wed 13:02
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algpseudocode}
\usepackage[margin=0.75in]{geometry}
\usepackage{nth}
\usepackage{tikz}
\usetikzlibrary{positioning,chains,fit,shapes,shapes.misc,calc,arrows,patterns,decorations.pathreplacing}
\usepackage{ccicons}
\usepackage{calc}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{nopageno}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{braket}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\setlength{\columnseprule}{1pt}
\newcommand{\bonusmarksamt}[1]{\textbf{[#1~BONUS~marks]}}
\newcommand{\bonusmarkamt}[0]{\textbf{[1~BONUS~mark]}}
\newcommand{\marksamt}[1]{\textbf{[#1~marks]}}
\newcommand{\markamt}[0]{\textbf{[1~mark]}}
\newcommand{\fillinMC}[1]{\fillinMCmath{\mbox{#1}}}
\newcommand{\fillinMCmath}[1]{\begin{tikzpicture}\draw circle [radius=0.5em];\end{tikzpicture}\ #1}
\newcommand{\fillinMCsoln}[1]{\fillinMCmathsoln{\mbox{#1}}}
\newcommand{\fillinMCmathsoln}[1]{\begin{tikzpicture}\draw[black, fill=blue] circle [radius=0.5em];\end{tikzpicture}\ #1}
\newcommand{\fillinMCAll}[1]{\fillinMCAllmath{\mbox{#1}}}
\newcommand{\fillinMCAllmath}[1]{\begin{tikzpicture}\draw (0,0) rectangle (1em,1em);\end{tikzpicture}\ #1}
\newcommand{\fillinMCAllsoln}[1]{\fillinMCAllmathsoln{\mbox{#1}}}
\newcommand{\fillinMCAllmathsoln}[1]{\begin{tikzpicture}\draw[black, fill=blue] (0,0) rectangle (1em,1em);\end{tikzpicture}\ #1}
\newcommand{\fillinblank}[1]{\fillinblankmath{\mbox{#1}}}
\newcommand{\fillinblankmath}[1]{\begingroup\setlength{\fboxsep}{1em}\setlength{\fboxrule}{2pt}\fbox{\LARGE\phantom{#1}}\endgroup}
\newcommand{\fillinblanksoln}[1]{\fillinblankmathsoln{\mbox{#1}}}
\newcommand{\fillinblankmathsoln}[1]{\begingroup\setlength{\fboxsep}{1em}\setlength{\fboxrule}{2pt}\fbox{{#1}}\endgroup}
\newcommand{\answerbox}[1][3\baselineskip]{%
\noindent\setlength{\fboxrule}{2pt}\framebox[0.7\linewidth]{%
\raisebox{2pt}[0pt][#1]{}%
}\par\medskip%
}
\usepackage{collcell,array}
\newcommand{\shiftdown}[1]{\smash{\raisebox{-.5\normalbaselineskip}{#1}}}
\newcolumntype{C}{>{\collectcell\shiftdown}c<{\endcollectcell}}
\newcommand{\shiftup}[1]{\smash{\raisebox{.5\normalbaselineskip}{#1}}}
\def\sequence#1#2{\dsequence{#1}{1}{#2}}
\def\dsequence#1#2#3{#1_{#2}, \ldots, #1_{#3}}
\newtheorem{fact}{Fact}
\def\imax{$\texttt{S}_{\max}$}
\def\iprevmax{previous\_$\texttt{S}_{\max}$}
\def\deleted{\texttt{covered}}
%%% Adding Colour to Questions and Answers
\usepackage{color}
%Questions
\def\question#1{\red{#1}}
% Answers
%Answer in short form
\def\ans#1{\par\blu{Answer: #1}}%With header of Answer
\def\soln#1{\par\blu{#1}} %Without header of Answer
% Colors
\definecolor{blu}{rgb}{0,0,0.5}
\def\blu#1{{\color{blu}#1}}
\definecolor{gre}{rgb}{0,.3,0}
\def\gre#1{{\color{gre}#1}}
\definecolor{red}{rgb}{0.5,0.0,0}
\def\red#1{{\color{red}#1}}
\def\norm#1{\|#1\|}
%%% End for Colours
\usepackage{collcell,array}
\newcolumntype{C}{>{\collectcell\shiftdown}c<{\endcollectcell}}
%\fancyhead{}\fancyfoot[C]{\tiny This work is licensed under a \href{http://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License. \ccby}\\ For license purposes, the author is the University of British Columbia.}\pagestyle{fancyplain}
\makeatletter
\def\@myproof#1[#2]{\trivlist \item [\hskip\labelsep{\bf #1 {#2}: }]}
\def\@begproof#1{\@ifnextchar[{\@myproof{#1}}{\@myproof{#1}[\unskip$\,$]}}
\newenvironment{solution}{\vskip -10pt\leavevmode\@begproof{Solution}}{\endtrivlist}
\def\sopt{S_{\textit{\scriptsize opt}}}
\makeatother
\fancyhead{}\fancyfoot[C]{\tiny This work is licensed under a \href{http://creativecommons.org/licenses/by-nc/4.0/}{Creative Commons Attribution-NonCommercial 4.0 International License. \ccbync}\\ For license purposes, the author is the University of British Columbia.}\pagestyle{fancyplain}
\usepackage{mdframed}
\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}
\date{}
\title{CPSC 320 2018W2: Assignment 3}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.2.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\vspace{-0.5in}

These problems touch on greedy algorithms and divide and conquer
algorithms. You'll also work on related problems
in your week 6 and 7 classes and tutorials.

Please follow the guidelines given in Assignment 1 for submission to
Gradescope, and for group collaboration. Remember to provide short
justifications for your answers. Submit by the deadline \textbf{Monday 
February 18, 2019 at 10PM}.

For this and future assignments, you must use \LaTeX to prepare your
answers. Easiest will be to use the .tex file provided. For questions
where you need to select a circle, you can change \verb~\fillinMCmath~ to
\verb~\fillinMCmathsoln~ for your choice of answer.  Similarly, for a "fill
in the box" question, you can change \verb~\fillinblank{?}~ to
\verb~\fillinblanksoln{Your solution here}~.  (And so on.)

Please enclose each paragraph
of your solution in \verb~\soln{Your solution here...}~.  
\soln{Your solution will then appear in dark blue}, making it a lot easier for
TAs to find the parts that you wrote.

\section{You are such a cheapskate!}
\label{sec-1}
Your significant other has a list of $n$ ``special
dates'' for which you are expected to treat them to dinner. Associated
with each special date $s$ is a deadline $d$ with $s \le d$.  In order
to earn credit for date $s$, you should schedule the dinner 
within the window $[s,d]$. That is, the dinner must be on or after day $s$
and on or before day $d$. Otherwise you will suffer unspeakable
consequences. (For instances of the problem in which an
inordinate number of special dates and deadlines lie in a very short
window, you may have to schedule more than one dinner on the same date
in order to meet the constraints; this is allowed!)

One dinner can credit up to $k$ special days. For instance, suppose
that $k=2$, there is a special day on February 10 with a deadline of
February 24, and another special day on February 14 with a deadline of
February 18. Then you can buy your partner dinner on February 16 to
credit both of these special dates, but can't cover any other special
dates with this dinner. 

Given a set $P$ of windows (that is, pairs $(s,d)$ with $s \le d$)
and a number $k \ge 1$, the following algorithm 
minimizes the number of dinner dates.
(After all, you are very busy with your studies and cannot
afford to take many evenings off.)
The algorithm greedily schedules a dinner on the earliest deadline,
then chooses as many pairs as possible (up to $k$) that are "covered"
by this dinner, choosing those pairs with the earliest deadlines.  The
process is repeated on the remaining subproblem until all special
dates are covered. The algorithm's output is
a list of days on which you go out for dinner together.

\begin{tabbing}
xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\= \kill
\> {\bf Algorithm} Choose-Dinner-Dates($P, k$) \\
\>\>   If $n = 0$ \\
\>\>\>   Return the empty list \\
\>\>   Else \\
\>\>\>   Set $d_{\min}$ to be the earliest deadline of any pair in $P$ \\
\>\>\>   $i=0$ \\
\>\>\>   While $i<k$ and there is some pair $(s',d')$ in $P$ with $s' \le d_{\min}$ \\
\>\>\>\>    Choose such a pair $(s',d')$ with the earliest deadline (i.e., smallest $d'$) \\
\>\>\>\>    Remove pair $(s',d')$ from $P$ \\
\>\>\>\>    Increment $i$ \\
\>\>\>   Return $\{d_{\min}\}$ $+$ Choose-Dinner-Dates($P,k$) 
\end{tabbing}

\begin{enumerate}
\item \question{Give a moderately-sized ($n \le 8$, $k \le 3$) instance, showing the dates where this greedy solution schedules the dinners, and a different optimal (not necessarily greedy) solution also  scheduling a minimal number of dinners.}  
   A diagram may be helpful in illustrating your instance and solutions.

\item \question{Show that Algorithm Choose-Dinner-Dates produces a valid solution, that is, one for which you earn credit for every special date.}

\item \question{Show that Algorithm Choose-Dinner-Dates produces an optimal solution, that is, one that minimizes the number of dinners scheduled.}

\item \question{What data structures could you use to ensure a running time of $O(n \log n)$? (Don't forget to justify your answer.)}

\item A different greedy algorithm
schedules a dinner on the latest start date and works
backwards.  \question{Give pseudocode that does this.} (You do not need
to provide any justification or reasoning about your algorithm.)
\end{enumerate}
\section{More on another spanning algorithm}
\label{sec-2}
This problem builds on your tutorial problem for week 6. 
Let $G = (V,E)$ denote a connected, undirected graph with $n\ge 2$
nodes and $m$ weighted edges. Let wt($e$) denote the weight of edge
$e$ of $G$. The following algorithm is similar but not identical to
Kruskal's minimum spanning tree algorithm. (This version of the
algorithm is interesting because it can be implemented efficiently
on a multi-processor computer. Roughly this is because the steps
for each connected component $C$ can all be handled by different processors.)

\begin{tabbing}
xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\= \kill
\> {\bf Algorithm} Spanning($G = (V,E)$, wt()) \\
\>\>    \\
\>\> Let $G'= (V,E')$ where $E' = \emptyset$ \\
\>\> While $G'$ is not connected \\
\>\>\> $E$-new $= \emptyset$ \\
\>\>\>  For each connected component $C$ of $G' = (V, E')$ \\
\>\>\>\>   Find an edge $e =(u,v) \in E$ of minimum weight wt($e$) that \\
\>\>\>\>   connects a node $u$ in $C$ to a node $v$ that is {\em not} in $C$ \\
\>\>\>\>   $E$-new $= E$-new $\cup \{e\}$ \\
\>\>\> $E' = E' \cup E$-new \\
\>\> Return $G'$ \\
\end{tabbing}

\begin{enumerate}
\item \question{Explain why the algorithm always returns a tree on all inputs $G = (V,E)$ where all edges of $E$ have different weights.}

\item \question{Explain why the tree returned by the algorithm is a minimum spanning tree on all inputs $G = (V,E)$ where all edges of $E$ have different weights.}
\end{enumerate}

\section{Runs of zeros}
\label{sec-3}
A \emph{run of 0's} in a binary string $s$ of length at least 1 is a substring $s'$ of $s$ consisting
only of 0's, such that each end of the substring is either adjacent
to a 1 or is also the end of the whole string $s$. For example,
the string 101100 has two runs of 0's, one of length 1 and one of
length 2 and the string 000 has one run of 0's of length 3, namely
the whole string itself.

Let $R(n)$ be the total number of runs of 0's, taken over all binary
strings of size $n \ge 1$.

\begin{enumerate}
\item \question{Give values for $R(1)$ and $R(2)$}:

\hspace{.5in}
$R(1)$: \fillinblank{?}
\hspace{.5in}
$R(2)$: \fillinblank{?}

\item \question{Provide a recurrence relation for $R(n)$, $n \ge 1$.}

\item \question{Justify why your recurrence is correct.}

\item \question{Solve your recurrence, to express $R(n)$ as a function of $n$.}
\end{enumerate}
\section{Nuts and bolts}
\label{sec-4}
This problem builds on your tutorial problem for week 7. 
You have to sort a bag of $n$ nuts and $n$ bolts by size, producing an
output of $n$ (nut, bolt) pairs that fit together.  In part because
the sizes are similar, and in part because you also want to watch
videos while sorting, you are not relying on eyesight as you do
this. So, the only way that you can tell if a particular bolt fits a
particular nut is by trying to thread the bolt into the nut.  
You realize that you might be able to accomplish the task
efficiently by using nuts and bolts that you match as a way to
filter the rest. The following algorithm captures this idea.

\begin{tabbing}
xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\=xxxx\= \kill
\> {\bf Algorithm} NB-Quick(Nut-Set, Bolt-Set) \\
\>\> If Nut-Set is empty, then \\
\>\>\>   Return the empty set \\
\>\> Else If Nut-Set contains exactly one nut, say $N$, then \\
\>\>\>   Let $B$ be the single bolt in Bolt-Set \\
\>\>\>   Return $\{ (N,B) \}$ \\
\>\> Else \\
\>\>\>   Remove a nut, say $N$, from Nut-Set \\
\>\>\>   Partner-found $=$ False \\
\>\>\>   Tried-Bolts $= \emptyset$ \\
\>\>\>   While not Partner-found \\
\>\>\>\>    Remove any bolt, say $B$, from Bolt-Set \\
\>\>\>\>    If bolt $B$ threads into nut $N$ then \\
\>\>\>\>\>    Partner-found $=$ True \\
\>\>\>\>    Else \\
\>\>\>\>\>     Add $B$ to Tried-Bolts         \\
\>\>\>   For each nut in Nut-Set\\
\>\>\>\>    If the nut is too loose for $B$\\
\>\>\>\>\>    Add it to the set Loose-Nuts\\
\>\>\>\>  Else add it to the set Tight-Nuts\\
\>\>\>   For each bolt in Bolt-Set $\cup$ Tried-Bolts\\
\>\>\>\>    If the bolt is too large for $N$\\
\>\>\>\>\>    Add it to the set Large-Bolts\\
\>\>\>\>  Else add it to the set Small-Bolts\\
\>\>\> Return $\{ (N,B) \} \cup$ NB-Quick(Loose-Nuts, Large-Bolts)\\
\>\>\> \phantom{Return $\{ (N,B) \}$}$\cup$ NB-Quick(Tight-Nuts, Small-Bolts)
\end{tabbing}

\begin{enumerate}
\item Consider  the case  where,  at  every recursive  call,  both  of the  sets
Tight-Nuts and  Loose-Nuts have size  in the range $[n/k,  (k-1)n/k]$, for
some  integer $k  > 2$.  
\question{Write  a recurrence  relation for the running time of this algorithm.}
\[
   T(n) \le \left\{ \begin{array}{ll} 
                    c, \qquad \qquad \qquad \qquad\mbox{when $n=0$ or $n=1$} & \mbox{// base cases} \\[.3in]
                    \fillinblankmath{XXXXXXXXXXXXXXXXXX} & // \mbox{recursive case} \\
                    \end{array} \right.
   \]

\item \question{Solve your recurrence to get a good asymptotic (big-$O$) upper-bound on the  running time of this algorithm, as a function of both $n$ and $k$.}
\end{enumerate}
% Emacs 25.2.1 (Org mode 8.2.10)
\end{document}
