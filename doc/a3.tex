% Created 2019-02-06 Wed 13:02
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algpseudocode}
\usepackage[margin=0.75in]{geometry}
\usepackage{nth}
\usepackage{tikz}
\usetikzlibrary{positioning,chains,fit,shapes,shapes.misc,calc,arrows,patterns,decorations.pathreplacing}
\usepackage{ccicons}
\usepackage{calc}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{nopageno}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{braket}
\usepackage{tikz}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\setlength{\columnseprule}{1pt}
\newcommand{\bonusmarksamt}[1]{\textbf{[#1~BONUS~marks]}}
\newcommand{\bonusmarkamt}[0]{\textbf{[1~BONUS~mark]}}
\newcommand{\marksamt}[1]{\textbf{[#1~marks]}}
\newcommand{\markamt}[0]{\textbf{[1~mark]}}
\newcommand{\fillinMC}[1]{\fillinMCmath{\mbox{#1}}}
\newcommand{\fillinMCmath}[1]{\begin{tikzpicture}\draw circle [radius=0.5em];\end{tikzpicture}\ #1}
\newcommand{\fillinMCsoln}[1]{\fillinMCmathsoln{\mbox{#1}}}
\newcommand{\fillinMCmathsoln}[1]{\begin{tikzpicture}\draw[black, fill=blue] circle [radius=0.5em];\end{tikzpicture}\ #1}
\newcommand{\fillinMCAll}[1]{\fillinMCAllmath{\mbox{#1}}}
\newcommand{\fillinMCAllmath}[1]{\begin{tikzpicture}\draw (0,0) rectangle (1em,1em);\end{tikzpicture}\ #1}
\newcommand{\fillinMCAllsoln}[1]{\fillinMCAllmathsoln{\mbox{#1}}}
\newcommand{\fillinMCAllmathsoln}[1]{\begin{tikzpicture}\draw[black, fill=blue] (0,0) rectangle (1em,1em);\end{tikzpicture}\ #1}
\newcommand{\fillinblank}[1]{\fillinblankmath{\mbox{#1}}}
\newcommand{\fillinblankmath}[1]{\begingroup\setlength{\fboxsep}{1em}\setlength{\fboxrule}{2pt}\fbox{\LARGE\phantom{#1}}\endgroup}
\newcommand{\fillinblanksoln}[1]{\fillinblankmathsoln{\mbox{#1}}}
\newcommand{\fillinblankmathsoln}[1]{\begingroup\setlength{\fboxsep}{1em}\setlength{\fboxrule}{2pt}\fbox{{#1}}\endgroup}
\newcommand{\answerbox}[1][3\baselineskip]{%
\noindent\setlength{\fboxrule}{2pt}\framebox[0.7\linewidth]{%
\raisebox{2pt}[0pt][#1]{}%
}\par\medskip%
}
\usepackage{collcell,array}
\newcommand{\shiftdown}[1]{\smash{\raisebox{-.5\normalbaselineskip}{#1}}}
\newcolumntype{C}{>{\collectcell\shiftdown}c<{\endcollectcell}}
\newcommand{\shiftup}[1]{\smash{\raisebox{.5\normalbaselineskip}{#1}}}
\def\sequence#1#2{\dsequence{#1}{1}{#2}}
\def\dsequence#1#2#3{#1_{#2}, \ldots, #1_{#3}}
\newtheorem{fact}{Fact}
\def\imax{$\texttt{S}_{\max}$}
\def\iprevmax{previous\_$\texttt{S}_{\max}$}
\def\deleted{\texttt{covered}}
%%% Adding Colour to Questions and Answers
\usepackage{color}
%Questions
\def\question#1{\red{#1}}
% Answers
%Answer in short form
\def\ans#1{\par\blu{Answer: #1}}%With header of Answer
\def\soln#1{\par\blu{#1}} %Without header of Answer
% Colors
\definecolor{blu}{rgb}{0,0,0.5}
\def\blu#1{{\color{blu}#1}}
\definecolor{gre}{rgb}{0,.3,0}
\def\gre#1{{\color{gre}#1}}
\definecolor{red}{rgb}{0.5,0.0,0}
\def\red#1{{\color{red}#1}}
\def\norm#1{\|#1\|}
%%% End for Colours
\usepackage{collcell,array}
\newcolumntype{C}{>{\collectcell\shiftdown}c<{\endcollectcell}}
%\fancyhead{}\fancyfoot[C]{\tiny This work is licensed under a \href{http://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License. \ccby}\\ For license purposes, the author is the University of British Columbia.}\pagestyle{fancyplain}
\makeatletter
\def\@myproof#1[#2]{\trivlist \item [\hskip\labelsep{\bf #1 {#2}: }]}
\def\@begproof#1{\@ifnextchar[{\@myproof{#1}}{\@myproof{#1}[\unskip$\,$]}}
\newenvironment{solution}{\vskip -10pt\leavevmode\@begproof{Solution}}{\endtrivlist}
\def\sopt{S_{\textit{\scriptsize opt}}}
\makeatother
\fancyhead{}\fancyfoot[C]{\tiny This work is licensed under a \href{http://creativecommons.org/licenses/by-nc/4.0/}{Creative Commons Attribution-NonCommercial 4.0 International License. \ccbync}\\ For license purposes, the author is the University of British Columbia.}\pagestyle{fancyplain}
\usepackage{mdframed}
\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}
\date{}
\title{CPSC 320 2018W2: Assignment 3}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.2.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\vspace{-0.5in}

These problems touch on greedy algorithms and divide and conquer
algorithms. You'll also work on related problems
in your week 6 and 7 classes and tutorials.

Please follow the guidelines given in Assignment 1 for submission to
Gradescope, and for group collaboration. Remember to provide short
justifications for your answers. Submit by the deadline \textbf{Monday 
February 18, 2019 at 10PM}.

For this and future assignments, you must use \LaTeX to prepare your
answers. Easiest will be to use the .tex file provided. For questions
where you need to select a circle, you can change \verb~\fillinMCmath~ to
\verb~\fillinMCmathsoln~ for your choice of answer.  Similarly, for a "fill
in the box" question, you can change \verb~\fillinblank{?}~ to
\verb~\fillinblanksoln{Your solution here}~.  (And so on.)

Please enclose each paragraph
of your solution in \verb~\soln{Your solution here...}~.  
\soln{Your solution will then appear in dark blue}, making it a lot easier for
TAs to find the parts that you wrote.

\section{You are such a cheapskate!}
\label{sec-1}
Your significant other has a list of $n$ ``special
dates'' for which you are expected to treat them to dinner. Associated
with each special date $s$ is a deadline $d$ with $s \le d$.  In order
to earn credit for date $s$, you should schedule the dinner 
within the window $[s,d]$. That is, the dinner must be on or after day $s$
and on or before day $d$. Otherwise you will suffer unspeakable
consequences. (For instances of the problem in which an
inordinate number of special dates and deadlines lie in a very short
window, you may have to schedule more than one dinner on the same date
in order to meet the constraints; this is allowed!)

One dinner can credit up to $k$ special days. For instance, suppose
that $k=2$, there is a special day on February 10 with a deadline of
February 24, and another special day on February 14 with a deadline of
February 18. Then you can buy your partner dinner on February 16 to
credit both of these special dates, but can't cover any other special
dates with this dinner. 

Given a set $P$ of windows (that is, pairs $(s,d)$ with $s \le d$)
and a number $k \ge 1$, the following algorithm 
minimizes the number of dinner dates.
(After all, you are very busy with your studies and cannot
afford to take many evenings off.)
The algorithm greedily schedules a dinner on the earliest deadline,
then chooses as many pairs as possible (up to $k$) that are "covered"
by this dinner, choosing those pairs with the earliest deadlines.  The
process is repeated on the remaining subproblem until all special
dates are covered. The algorithm's output is
a list of days on which you go out for dinner together.

\begin{tabbing}
xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\= \kill
\> {\bf Algorithm} Choose-Dinner-Dates($P, k$) \\
\>\>   If $n = 0$ \\
\>\>\>   Return the empty list \\
\>\>   Else \\
\>\>\>   Set $d_{\min}$ to be the earliest deadline of any pair in $P$ \\
\>\>\>   $i=0$ \\
\>\>\>   While $i<k$ and there is some pair $(s',d')$ in $P$ with $s' \le d_{\min}$ \\
\>\>\>\>    Choose such a pair $(s',d')$ with the earliest deadline (i.e., smallest $d'$) \\
\>\>\>\>    Remove pair $(s',d')$ from $P$ \\
\>\>\>\>    Increment $i$ \\
\>\>\>   Return $\{d_{\min}\}$ $+$ Choose-Dinner-Dates($P,k$) 
\end{tabbing}

\begin{enumerate}
\item \question{Give a moderately-sized ($n \le 8$, $k \le 3$) instance, showing the dates where this greedy solution schedules the dinners, and a different optimal (not necessarily greedy) solution also  scheduling a minimal number of dinners.}  
   A diagram may be helpful in illustrating your instance and solutions.

\soln{
   Instance of "Special dates":
   \[
      P = [(5,8), (4,10), (7,7), (3,8), (6,7), (9,10), (11,12), (15,20)]
   \]
   \[ k = 3\]
   \begin{tikzpicture}
      \draw [|-|,thick] (5,0) -- (8,0);
      \node[align=center, above] at (6.5,0){1};
      \node[align=center, below] at (5,-0.2){5};
      \node[align=center, below] at (8,-0.2){8};
      \draw [|-|,thick] (4,-1) -- (10,-1);
      \node[align=center, above] at (7.0,-1){2};
      \node[align=center, below] at (4,-1.2){4};
      \node[align=center, below] at (10,-1.2){10};
      \draw [|-|,thick] (7,-2) -- (7,-2);
      \node[align=center, above] at (7.0,-2){3};
      \node[align=center, below] at (7,-2.2){7};
      \node[align=center, below] at (7,-2.2){7};
      \draw [|-|,thick] (3,-3) -- (8,-3);
      \node[align=center, above] at (5.5,-3){4};
      \node[align=center, below] at (3,-3.2){3};
      \node[align=center, below] at (8,-3.2){8};
      \draw [|-|,thick] (6,-4) -- (7,-4);
      \node[align=center, above] at (6.5,-4){5};
      \node[align=center, below] at (6,-4.2){6};
      \node[align=center, below] at (7,-4.2){7};
      \draw [|-|,thick] (9,-5) -- (10,-5);
      \node[align=center, above] at (9.5,-5){6};
      \node[align=center, below] at (9,-5.2){9};
      \node[align=center, below] at (10,-5.2){10};
      \draw [|-|,thick] (11,-6) -- (12,-6);
      \node[align=center, above] at (11.5,-6){7};
      \node[align=center, below] at (11,-6.2){11};
      \node[align=center, below] at (12,-6.2){12};
      \draw [|-|,thick] (15,-7) -- (20,-7);
      \node[align=center, above] at (17.5,-7){8};
      \node[align=center, below] at (15,-7.2){15};
      \node[align=center, below] at (20,-7.2){20};
   \end{tikzpicture}
   Solution for Choose-Dinner-Dates: 
   \[ [7, 7, 10, 12, 20] \]
   Different solution: 
   \[ [7, 8, 10, 11, 15] \]
}

\item \question{Show that Algorithm Choose-Dinner-Dates produces a valid solution, that is, one for which you earn credit for every special date.}
\soln{
   On each call to the algorithm we get the earliest deadline $d_{min}$ of all $P$ and remove from $P$ at most $k$ 
   elements of $P$ that have an $s <= d_{min}$. By doing this every element we delete from $P$ will receive a credit for a 
   date on $d_{min}$. This is because $d_{min}$ is the earliest deadline in $P$, so we can cover from $d_{min}$ all 
   the "special dates" that have a start $s$ less than or equal to $d_{min}$, because we know that their corresponding 
   deadlines must be equal or greater than $d_{min}$.
}

\item \question{Show that Algorithm Choose-Dinner-Dates produces an optimal solution, that is, one that minimizes the number of dinners scheduled.}
\soln{
   Consider the following solutions for the instance in question 1:
   \[ S = [7, 7, 10, 12, 20] \text{ -> Choose-Dinner-Dates solution}\]
   We know that S will be sorted in increasing order because the algorithm on each call it selects $d_{min}$ as the earliest 
   deadline, so the next earliest deadline in the recursive call has to be equal or greater than $d_{min}$ \\
   \[ S' = [7, 8, 10, 11, 15] \text{ -> Different optimal solution} \]
   We assume that S' will be sorted in increasing order \\ 
   let $s = S[1]$ \\
   let $s' = S'[1]$ \\
   By switching $s'$ with $s$, $S'$ will still give us a valid solution, because we know there is no other element in 
   $P$ with an earlier deadline than $s$. So every element in $P$ that has received a credit by having a date on $s'$ 
   will also receive a credit by having a date on $s$, because $s'$ must be less than or equal to $s$. \\ \\ 
   If $s'$ was greater than $s$ then $S'$ won't be a valid solution, because we know that there exists a 
   "special date" in $P$ that doesn't receive a credit by having a date on $s'$, because $s$ is the earliest deadline 
   of all the dates in $P$.\\ \\
   We can repeat the swap on the elements $S[i]$ and $S'[i]$ at any index $i$ and the solution $S'$ will still 
   be a valid solution and since we know $S'$ is an optimal solution, then $S$ has to be optimal.
}

\item \question{What data structures could you use to ensure a running time of $O(n \log n)$? (Don't forget to justify your answer.)}
\soln{
   To ensure a running time of $O(n \log n)$ I would use a priority queue to store $P$. This will allow us to access 
   the min element, i.e. the earliest deadline $d_{min}$ in constant time, and to delete an element from it in 
   $\log n$. \\ \\
   So for the case in which $k=n$ and all elements have the same deadline, then the while will take $O(n)$ time 
   by going through all elements, $O(1)$ to find the min deadline in $P$ and $O(\log n)$ deleting at each iteration one,
   which will have a total running time of $O(n \log n)$. 
}

\item A different greedy algorithm
schedules a dinner on the latest start date and works
backwards.  \question{Give pseudocode that does this.} (You do not need
to provide any justification or reasoning about your algorithm.)
\soln{
   \begin{tabbing}
   xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\= \kill
   \> {\bf Algorithm} Different-Dinner-Dates($P, k$) \\
   \>\>   If $n = 0$ \\
   \>\>\>   Return the empty list \\
   \>\>   Else \\
   \>\>\>   Set $s_{\max}$ to be the latest start date of any pair in $P$ \\
   \>\>\>   $i=0$ \\
   \>\>\>   While $i<k$ and there is some pair $(s',d')$ in $P$ with $d' \ge s_{\max}$ \\
   \>\>\>\>    Choose such a pair $(s',d')$ with the latest start date (i.e., greatest $s'$) \\
   \>\>\>\>    Remove pair $(s',d')$ from $P$ \\
   \>\>\>\>    Increment $i$ \\
   \>\>\>   Return $\{s_{\max}\}$ $+$ Different-Dinner-Dates($P,k$) 
   \end{tabbing}
}
\end{enumerate}
\section{More on another spanning algorithm}
\label{sec-2}
This problem builds on your tutorial problem for week 6. 
Let $G = (V,E)$ denote a connected, undirected graph with $n\ge 2$
nodes and $m$ weighted edges. Let wt($e$) denote the weight of edge
$e$ of $G$. The following algorithm is similar but not identical to
Kruskal's minimum spanning tree algorithm. (This version of the
algorithm is interesting because it can be implemented efficiently
on a multi-processor computer. Roughly this is because the steps
for each connected component $C$ can all be handled by different processors.)

\begin{tabbing}
xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\= \kill
\> {\bf Algorithm} Spanning($G = (V,E)$, wt()) \\
\>\>    \\
\>\> Let $G'= (V,E')$ where $E' = \emptyset$ \\
\>\> While $G'$ is not connected \\
\>\>\> $E$-new $= \emptyset$ \\
\>\>\>  For each connected component $C$ of $G' = (V, E')$ \\
\>\>\>\>   Find an edge $e =(u,v) \in E$ of minimum weight wt($e$) that \\
\>\>\>\>   connects a node $u$ in $C$ to a node $v$ that is {\em not} in $C$ \\
\>\>\>\>   $E$-new $= E$-new $\cup \{e\}$ \\
\>\>\> $E' = E' \cup E$-new \\
\>\> Return $G'$ \\
\end{tabbing}

\begin{enumerate}
\item \question{Explain why the algorithm always returns a tree on all inputs $G = (V,E)$ where all edges of $E$ have different weights.}
\soln{
   The problem with this algorithm that causes a solution that is not a tree, occurs when 
   two connected components, at the one iteration of the while loop, select different edges 
   that connect them together. In this case a cycle is introduced to the solution because 
   it creates two possible paths from one connected component to another one. \\ \\
   If all edges of E have different weights then we know that for each pair of connected 
   connected components there exists a single edge that has the lowest weight. Thus there is 
   no way the algorithm chooses another edge rather than that one to connect them, both 
   connected components must choose the same edge. So we can assume that when we connect 
   two connected components there wont be a cycle introduced in the solution. \\ \\ 
   This process is repeated for all the algorithm, guaranteeing no cycles if each edge in E 
   has a different weight, which will give us a tree as a solution. \\ 
}

\item \question{Explain why the tree returned by the algorithm is a minimum spanning tree on all inputs $G = (V,E)$ where all edges of $E$ have different weights.}
\soln{
   A tree returned by the algorithm will always have all the minimum weighted edges because 
   at each iteration when we add a new edge that will always be the minimum weighted edge
   that connects one connected component to another one. This will be repeated on all connected 
   components that we are connecting on each iteration, ensuring that G' always have the 
   minimum weighted edges. \\ \\
   Thus our solution will be a tree (proved on previous question), which means we have the 
   minimum number of edges that connect every single node in G, furthermore every edge in the 
   tree will have the minimum weight on it, this characteristics are the ones that make the 
   solution tree of this algorithm a minimum spanning tree.
}
\end{enumerate}

\section{Runs of zeros}
\label{sec-3}
A \emph{run of 0's} in a binary string $s$ of length at least 1 is a substring $s'$ of $s$ consisting
only of 0's, such that each end of the substring is either adjacent
to a 1 or is also the end of the whole string $s$. For example,
the string 101100 has two runs of 0's, one of length 1 and one of
length 2 and the string 000 has one run of 0's of length 3, namely
the whole string itself.

Let $R(n)$ be the total number of runs of 0's, taken over all binary
strings of size $n \ge 1$.

\begin{enumerate}
\item \question{Give values for $R(1)$ and $R(2)$}:

\hspace{.5in}
$R(1)$: \fillinblanksoln{1}
\hspace{.5in}
$R(2)$: \fillinblanksoln{3}

\item \question{Provide a recurrence relation for $R(n)$, $n \ge 1$.}

\item \question{Justify why your recurrence is correct.}

\item \question{Solve your recurrence, to express $R(n)$ as a function of $n$.}
\end{enumerate}
\section{Nuts and bolts}
\label{sec-4}
This problem builds on your tutorial problem for week 7. 
You have to sort a bag of $n$ nuts and $n$ bolts by size, producing an
output of $n$ (nut, bolt) pairs that fit together.  In part because
the sizes are similar, and in part because you also want to watch
videos while sorting, you are not relying on eyesight as you do
this. So, the only way that you can tell if a particular bolt fits a
particular nut is by trying to thread the bolt into the nut.  
You realize that you might be able to accomplish the task
efficiently by using nuts and bolts that you match as a way to
filter the rest. The following algorithm captures this idea.

\begin{tabbing}
xxxxxxx\=xxx\=xxx\=xxx\=xxx\=xxxx\=xxxx\= \kill
\> {\bf Algorithm} NB-Quick(Nut-Set, Bolt-Set) \\
\>\> If Nut-Set is empty, then \\
\>\>\>   Return the empty set \\
\>\> Else If Nut-Set contains exactly one nut, say $N$, then \\
\>\>\>   Let $B$ be the single bolt in Bolt-Set \\
\>\>\>   Return $\{ (N,B) \}$ \\
\>\> Else \\
\>\>\>   Remove a nut, say $N$, from Nut-Set \\
\>\>\>   Partner-found $=$ False \\
\>\>\>   Tried-Bolts $= \emptyset$ \\
\>\>\>   While not Partner-found \\
\>\>\>\>    Remove any bolt, say $B$, from Bolt-Set \\
\>\>\>\>    If bolt $B$ threads into nut $N$ then \\
\>\>\>\>\>    Partner-found $=$ True \\
\>\>\>\>    Else \\
\>\>\>\>\>     Add $B$ to Tried-Bolts         \\
\>\>\>   For each nut in Nut-Set\\
\>\>\>\>    If the nut is too loose for $B$\\
\>\>\>\>\>    Add it to the set Loose-Nuts\\
\>\>\>\>  Else add it to the set Tight-Nuts\\
\>\>\>   For each bolt in Bolt-Set $\cup$ Tried-Bolts\\
\>\>\>\>    If the bolt is too large for $N$\\
\>\>\>\>\>    Add it to the set Large-Bolts\\
\>\>\>\>  Else add it to the set Small-Bolts\\
\>\>\> Return $\{ (N,B) \} \cup$ NB-Quick(Loose-Nuts, Large-Bolts)\\
\>\>\> \phantom{Return $\{ (N,B) \}$}$\cup$ NB-Quick(Tight-Nuts, Small-Bolts)
\end{tabbing}

\begin{enumerate}
\item Consider  the case  where,  at  every recursive  call,  both  of the  sets
Tight-Nuts and  Loose-Nuts have size  in the range $[n/k,  (k-1)n/k]$, for
some  integer $k  > 2$.  
\question{Write  a recurrence  relation for the running time of this algorithm.}
\[
   T(n) \le \left\{ \begin{array}{ll} 
                    c, \qquad \qquad \qquad \qquad\mbox{when $n=0$ or $n=1$} & \mbox{// base cases} \\[.3in]
                    \fillinblankmath{XXXXXXXXXXXXXXXXXX} & // \mbox{recursive case} \\
                    \end{array} \right.
   \]

\item \question{Solve your recurrence to get a good asymptotic (big-$O$) upper-bound on the  running time of this algorithm, as a function of both $n$ and $k$.}
\end{enumerate}
% Emacs 25.2.1 (Org mode 8.2.10)
\end{document}
